import numpy as np
from numpy import sqrt
import matplotlib.pyplot as plt

def length(v):
    '''Return the length of the vector v.'''
    v = np.array(v)
    return sqrt(np.sum(v * v))

def angle(u,v):
    '''Return the angle between vectors u and v.'''
    u = np.array(u)
    v = np.array(v)
    return np.arccos(np.sum(u * v) / sqrt(np.sum(u * u) * np.sum(v * v))) * 180/np.pi

def plotvectors(lst, colors=None):
    '''Plot a list of 2D vectors. You can optionally provide a list of colors.'''
    
    xcoords = [v[0] for v in lst]
    ycoords = [v[1] for v in lst]
    if not colors:
        plt.quiver([0 for v in lst], [0 for v in lst], xcoords, ycoords, scale_units='xy', angles='xy', scale=1)
    else:
        plt.quiver([0 for v in lst], [0 for v in lst], xcoords, ycoords, scale_units='xy', angles='xy', scale=1, color=colors)
    maxx = max(xcoords + [0])
    minx = min(xcoords + [0])
    xrange = maxx-minx
    maxy = max(ycoords + [0])
    miny = min(ycoords + [0])
    yrange = maxy-miny
    biggerrange = max(xrange, yrange)
    
    plt.xlim(minx - (biggerrange - xrange)/2, maxx + (biggerrange - xrange)/2)
    plt.ylim(miny - (biggerrange - yrange)/2, maxy + (biggerrange - yrange)/2)
    plt.gca().set_aspect('equal', adjustable='box')
    plt.show()

def proj(v,w):
    '''Project vector v onto vector w.'''
    v = np.array(v)
    w = np.array(w)
    return np.sum(v * w)/np.sum(w * w) * w

def GramSchmidt(lst):
    '''Orthogonalize the set of vectors lst.'''
    if len(lst) <= 1:
        return lst
    b1 = np.array(lst.pop(0))
    newlst = [b1]
    dim = np.shape(b1)
    for v in lst:
        projv = np.zeros(dim)
        for b in newlst:
            projv += proj(v,b)
        if not np.isclose(v-projv, np.zeros(dim)).all():
            newlst.append(v-projv)
    return newlst

def Proj(lst, v):
    '''Project vector v onto the subspace generated by the set of vectors lst.'''
    v = np.array(v)
    Projv = np.zeros(np.shape(v))
    if len(lst) == 0:
        return Projv
    for w in GramSchmidt(lst):
        w = np.array(w)
        Projv += np.sum(v * w)/np.sum(w * w) * w
    return Projv
    
def Rem(lst, v):
    '''The remainder after projecting vector v onto the subspace generated by the set of vectors lst.'''
    return v - Proj(lst, v)

def Findn(lst, u, v):
    '''Return the integer n which makes Rem(lst, v+nu) as short as possible.
    The output is 0 if and only if {u,v} is size-reduced (after taking the remainder of projection onto lst).'''
    
    ur = Rem(lst, u)
    vr = Rem(lst, v)
    return round(-np.sum(ur * vr)/np.sum(ur * ur))
    
    